"""
Main entry point for the AI Bot application with webhook support for Cloud Run
Using FastAPI for better performance and modern async support
"""
import os
import asyncio
import time
import threading
from typing import Optional
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
import httpx
from telegram import Update
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
    ConversationHandler,
    CallbackQueryHandler,
)
from telegram.error import Conflict, NetworkError
from config.locales.locale_manager import initialize_locale_manager

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞ Firestore
# –≠—Ç–æ—Ç –∫–æ–¥ –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤ Cloud Run
# –∏ –ø—Ä–∏ –ª–æ–∫–∞–ª—å–Ω–æ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–µ —Å –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ–∫—Ä—É–∂–µ–Ω–∏—è.
from google.cloud import firestore

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞ Firestore —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫
try:
    db = firestore.Client(database='billscaner')
    print("‚úÖ Firestore –∫–ª–∏–µ–Ω—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —É—Å–ø–µ—à–Ω–æ (–±–∞–∑–∞: billscaner)")
except Exception as e:
    print(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Firestore: {e}")
    print("üí° –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è GOOGLE_APPLICATION_CREDENTIALS —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞")
    print(f"üí° –¢–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {os.environ.get('GOOGLE_APPLICATION_CREDENTIALS', '–ù–ï –£–°–¢–ê–ù–û–í–õ–ï–ù–û')}")
    db = None

# –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å numpy/pandas –ø–µ—Ä–µ–¥ –∏–º–ø–æ—Ä—Ç–æ–º –¥—Ä—É–≥–∏—Ö –º–æ–¥—É–ª–µ–π
try:
    import numpy as np
    import pandas as pd
    print(f"‚úÖ numpy –≤–µ—Ä—Å–∏—è: {np.__version__}")
    print(f"‚úÖ pandas –≤–µ—Ä—Å–∏—è: {pd.__version__}")
except ImportError as e:
    print(f"‚ùå –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ numpy/pandas: {e}")
    # –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –∑–∞–ø—É—Å–∫, –µ—Å–ª–∏ numpy/pandas –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã
    np = None
    pd = None

# –ò–º–ø–æ—Ä—Ç—ã —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫
try:
    from config.settings import BotConfig
    from config.prompts import PromptManager
    from services.ai_service import AIService, ReceiptAnalysisService
    from handlers.message_handlers import MessageHandlers
    from handlers.callback_handlers import CallbackHandlers
    from utils.ingredient_storage import IngredientStorage
    from utils.message_sender import MessageSender
    from google_sheets_handler import get_google_sheets_ingredients
    print("‚úÖ –í—Å–µ –º–æ–¥—É–ª–∏ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã —É—Å–ø–µ—à–Ω–æ")
except ImportError as e:
    print(f"‚ùå –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ –º–æ–¥—É–ª–µ–π: {e}")
    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º None –¥–ª—è –≤—Å–µ—Ö –º–æ–¥—É–ª–µ–π
    BotConfig = None
    PromptManager = None
    AIService = None
    ReceiptAnalysisService = None
    MessageHandlers = None
    CallbackHandlers = None
    IngredientStorage = None
    MessageSender = None
    get_google_sheets_ingredients = None

# Bot configuration - –±—É–¥–µ—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –ø–æ–∑–∂–µ
TOKEN = None
TELEGRAM_API = None

# FastAPI app
app = FastAPI(title="AI Bot", description="Telegram Bot for receipt processing")

# Global variables
application: Optional[Application] = None
ingredient_storage: Optional[IngredientStorage] = None

def cleanup_old_files_periodically(ingredient_storage: IngredientStorage) -> None:
    """Background task to clean up old files every 30 minutes"""
    while True:
        try:
            time.sleep(1800)  # 30 minutes = 1800 seconds
            ingredient_storage.cleanup_old_files()
            print("üßπ –í—ã–ø–æ–ª–Ω–µ–Ω–∞ –æ—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö —Ñ–∞–π–ª–æ–≤ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è")
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ —Ñ–∞–π–ª–æ–≤: {e}")

def create_application() -> Application:
    """Create and configure the Telegram application"""
    # Check if all required modules are available
    if not all([BotConfig, PromptManager, AIService, ReceiptAnalysisService, 
                MessageHandlers, CallbackHandlers, IngredientStorage]):
        raise ImportError("Required modules are not available")
    
    # Initialize configuration
    config = BotConfig()
    prompt_manager = PromptManager()
    
    # Initialize services
    ai_service = AIService(config, prompt_manager)
    analysis_service = ReceiptAnalysisService(ai_service)
    
    # Initialize handlers
    message_handlers = MessageHandlers(config, analysis_service)
    callback_handlers = CallbackHandlers(config, analysis_service)
    
    # Initialize ingredient storage with 1 hour cleanup
    ingredient_storage = IngredientStorage(max_age_hours=1)
    
    # Create application
    application = Application.builder().token(TOKEN).concurrent_updates(True).build()
    
    # Initialize global LocaleManager
    initialize_locale_manager()
    
    # Initialize empty poster ingredients - will be loaded on demand
    application.bot_data["poster_ingredients"] = {}
    
    # Initialize empty Google Sheets ingredients - will be loaded on demand
    application.bot_data["google_sheets_ingredients"] = {}
    print("‚úÖ Google Sheets –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã –±—É–¥—É—Ç –∑–∞–≥—Ä—É–∂–µ–Ω—ã –ø–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—é")

    # Create conversation handler
    conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler("start", message_handlers.start),
            CommandHandler("reset_language", message_handlers.reset_language),
            CommandHandler("dashboard", message_handlers.dashboard),
            MessageHandler(filters.PHOTO, message_handlers.handle_photo)
        ],
        states={
            config.AWAITING_CORRECTION: [
                CallbackQueryHandler(callback_handlers.handle_correction_choice),
                CommandHandler("dashboard", message_handlers.dashboard),
                MessageHandler(filters.TEXT & ~filters.COMMAND, message_handlers.handle_user_input),
                MessageHandler(filters.PHOTO, message_handlers.handle_photo)
            ],
            config.AWAITING_DASHBOARD: [
                CallbackQueryHandler(callback_handlers.handle_correction_choice),
                CommandHandler("dashboard", message_handlers.dashboard),
                MessageHandler(filters.TEXT & ~filters.COMMAND, message_handlers.handle_user_input),
                MessageHandler(filters.PHOTO, message_handlers.handle_photo)
            ],
            config.AWAITING_INPUT: [
                CommandHandler("dashboard", message_handlers.dashboard),
                MessageHandler(filters.TEXT & ~filters.COMMAND, message_handlers.handle_user_input),
                MessageHandler(filters.PHOTO, message_handlers.handle_photo)
            ],
            config.AWAITING_LINE_NUMBER: [
                CommandHandler("dashboard", message_handlers.dashboard),
                MessageHandler(filters.TEXT & ~filters.COMMAND, message_handlers.handle_line_number_input),
                MessageHandler(filters.PHOTO, message_handlers.handle_photo)
            ],
            config.AWAITING_FIELD_EDIT: [
                CallbackQueryHandler(callback_handlers.handle_correction_choice), 
                CommandHandler("dashboard", message_handlers.dashboard),
                MessageHandler(filters.TEXT & ~filters.COMMAND, message_handlers.handle_user_input),
                MessageHandler(filters.PHOTO, message_handlers.handle_photo)
            ],
            config.AWAITING_DELETE_LINE_NUMBER: [
                CommandHandler("dashboard", message_handlers.dashboard),
                MessageHandler(filters.TEXT & ~filters.COMMAND, message_handlers.handle_delete_line_number_input),
                MessageHandler(filters.PHOTO, message_handlers.handle_photo)
            ],
            config.AWAITING_TOTAL_EDIT: [
                CommandHandler("dashboard", message_handlers.dashboard),
                MessageHandler(filters.TEXT & ~filters.COMMAND, message_handlers.handle_total_edit_input),
                MessageHandler(filters.PHOTO, message_handlers.handle_photo)
            ],
            config.AWAITING_INGREDIENT_MATCHING: [
                CallbackQueryHandler(callback_handlers.handle_correction_choice),
                CommandHandler("dashboard", message_handlers.dashboard),
                MessageHandler(filters.PHOTO, message_handlers.handle_photo)
            ],
            config.AWAITING_MANUAL_MATCH: [
                CommandHandler("dashboard", message_handlers.dashboard),
                MessageHandler(filters.TEXT & ~filters.COMMAND, message_handlers.handle_ingredient_matching_input),
                CallbackQueryHandler(callback_handlers.handle_correction_choice),
                MessageHandler(filters.PHOTO, message_handlers.handle_photo)
            ],
        },
        fallbacks=[
            CommandHandler("cancel", message_handlers.start),
            CommandHandler("dashboard", message_handlers.dashboard)
        ],
        per_message=False
    )

    # Add handlers
    application.add_handler(conv_handler)
    
    return application

async def initialize_bot():
    """Initialize the bot application and start background tasks"""
    global application, ingredient_storage, TOKEN, TELEGRAM_API
    
    print("üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞...")
    
    # Debug: Print all environment variables
    print("üîç Debug: Environment variables:")
    for key, value in os.environ.items():
        if "TOKEN" in key or "PROJECT" in key or "WEBHOOK" in key:
            print(f"  {key}: {'*' * len(value) if value else 'NOT SET'}")
    
    # Check if BOT_TOKEN is available
    TOKEN = os.getenv("BOT_TOKEN")
    if not TOKEN:
        print("‚ùå BOT_TOKEN –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")
        print("üîç Available env vars with 'BOT':", [k for k in os.environ.keys() if 'BOT' in k])
        return
    
    TELEGRAM_API = f"https://api.telegram.org/bot{TOKEN}"
    print("‚úÖ BOT_TOKEN –Ω–∞–π–¥–µ–Ω")
    
    # Create application
    application = create_application()
    
    # Initialize ingredient storage with 1 hour cleanup
    ingredient_storage = IngredientStorage(max_age_hours=1)
    
    # Start background cleanup thread
    cleanup_thread = threading.Thread(target=cleanup_old_files_periodically, args=(ingredient_storage,), daemon=True)
    cleanup_thread.start()
    print("‚úÖ –§–æ–Ω–æ–≤—ã–π –ø–æ—Ç–æ–∫ –æ—á–∏—Å—Ç–∫–∏ –∑–∞–ø—É—â–µ–Ω")
    
    # Initialize the application
    await application.initialize()
    
    # Set webhook URL for Cloud Run
    webhook_url = os.environ.get("WEBHOOK_URL")
    if webhook_url:
        try:
            await application.bot.set_webhook(
                url=f"{webhook_url}/webhook",
                drop_pending_updates=True
            )
            print(f"‚úÖ Webhook —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {webhook_url}/webhook")
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ webhook: {e}")
    else:
        print("‚ö†Ô∏è WEBHOOK_URL –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")
    
    print("üöÄ –ë–æ—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –¥–ª—è webhook —Ä–µ–∂–∏–º–∞")

@app.on_event("startup")
async def startup_event():
    """Initialize bot on startup"""
    try:
        await initialize_bot()
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–æ—Ç–∞: {e}")
        import traceback
        traceback.print_exc()
        # –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –∑–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è, –µ—Å–ª–∏ –±–æ—Ç –Ω–µ –º–æ–∂–µ—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å—Å—è

@app.get("/")
async def health_check():
    """Health check endpoint for Cloud Run"""
    return {"status": "ok", "message": "AI Bot is running"}

@app.post("/set_webhook")
async def set_webhook(request: Request):
    """Manual webhook setup endpoint"""
    try:
        data = await request.json()
        webhook_url = data.get("webhook_url")
        if not webhook_url:
            raise HTTPException(status_code=400, detail="webhook_url is required")
        
        if not application:
            raise HTTPException(status_code=500, detail="Bot not initialized")
        
        result = await application.bot.set_webhook(
            url=f"{webhook_url}/webhook",
            drop_pending_updates=True
        )
        
        return {
            "status": "success", 
            "webhook_url": f"{webhook_url}/webhook",
            "result": result
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/get_webhook")
async def get_webhook():
    """Get current webhook info"""
    try:
        if not application:
            raise HTTPException(status_code=500, detail="Bot not initialized")
        
        webhook_info = await application.bot.get_webhook_info()
        
        return {
            "webhook_info": webhook_info.to_dict()
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

async def process_update_background(update_data: dict):
    """Process Telegram update in background"""
    try:
        if not application:
            print("‚ùå –ë–æ—Ç –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –¥–ª—è —Ñ–æ–Ω–æ–≤–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏")
            return
        
        update = Update.de_json(update_data, application.bot)
        print(f"üìä Parsed update: {update}")
        
        if not update:
            print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å update")
            return
        
        # Process the update
        await application.process_update(update)
        print("‚úÖ Update –æ–±—Ä–∞–±–æ—Ç–∞–Ω —É—Å–ø–µ—à–Ω–æ –≤ —Ñ–æ–Ω–æ–≤–æ–º —Ä–µ–∂–∏–º–µ")
        
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ–Ω–æ–≤–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–µ update: {e}")
        import traceback
        traceback.print_exc()

@app.post("/webhook")
async def webhook(request: Request):
    """Webhook endpoint for Telegram updates - returns immediately"""
    try:
        print("üì® –ü–æ–ª—É—á–µ–Ω webhook –∑–∞–ø—Ä–æ—Å")
        
        # Get headers info
        headers = dict(request.headers)
        print(f"üìä Headers: {headers}")
        print(f"üìä Content-Type: {headers.get('content-type', 'unknown')}")
        
        # Get the update from Telegram
        update_data = await request.json()
        print(f"üìä Update data: {update_data}")
        
        if not update_data:
            print("‚ùå –ü—É—Å—Ç—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Ç Telegram")
            return {"ok": True}
        
        if not application:
            print("‚ùå –ë–æ—Ç –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            return {"ok": True, "error": "Bot not initialized"}
        
        # Start background processing and return immediately
        asyncio.create_task(process_update_background(update_data))
        
        print("‚úÖ Update –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ —Ñ–æ–Ω–æ–≤—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É")
        return {"ok": True}
        
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ webhook: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    port = int(os.environ.get("PORT", 8080))
    uvicorn.run(app, host="0.0.0.0", port=port)