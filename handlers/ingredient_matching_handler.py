"""
Ingredient matching callback handlers
"""
from typing import Optional
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes

from config.settings import BotConfig
from models.receipt import ReceiptData
from models.ingredient_matching import IngredientMatchingResult
from services.ai_service import ReceiptAnalysisService
from services.ingredient_matching_service import IngredientMatchingService
from utils.ingredient_formatter import IngredientFormatter
from utils.ingredient_storage import IngredientStorage
from utils.ui_manager import UIManager


class IngredientMatchingHandler:
    """Handler for ingredient matching operations"""
    
    def __init__(self, config: BotConfig, analysis_service: ReceiptAnalysisService):
        self.config = config
        self.analysis_service = analysis_service
        self.ingredient_matching_service = IngredientMatchingService()
        self.ingredient_formatter = IngredientFormatter()
        self.ingredient_storage = IngredientStorage()
        self.ui_manager = UIManager(config)
    
    async def handle_correction_choice(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """Handle correction choice actions"""
        query = update.callback_query
        await query.answer()
        
        action = query.data
        
        if action == "match_ingredients":
            await query.answer("üîç –ó–∞–≥—Ä—É–∂–∞—é —Ç–∞–±–ª–∏—Ü—É —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤...")
            
            await self.ui_manager.cleanup_all_except_anchor(update, context)
            
            receipt_data = context.user_data.get('receipt_data')
            if not receipt_data:
                await query.message.reply_text("–û—à–∏–±–∫–∞: –¥–∞–Ω–Ω—ã–µ —á–µ–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
                return self.config.AWAITING_CORRECTION
            
            if not await self._ensure_poster_ingredients_loaded(context):
                await query.message.reply_text("‚ùå –û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫ –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤ –∏–∑ Poster.\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
                return self.config.AWAITING_CORRECTION
            
            poster_ingredients = context.bot_data.get('poster_ingredients', {})
            user_id = update.effective_user.id
            receipt_hash = receipt_data.get_receipt_hash()
            
            # Try to load from storage first
            saved_data = self.ingredient_storage.load_matching_result(user_id, receipt_hash)
            
            if saved_data:
                matching_result, changed_indices = saved_data
                context.user_data['ingredient_matching_result'] = matching_result
                context.user_data['changed_ingredient_indices'] = changed_indices
                context.user_data['current_match_index'] = 0
            else:
                matching_result = self.ingredient_matching_service.match_ingredients(receipt_data, poster_ingredients)
                context.user_data['ingredient_matching_result'] = matching_result
                context.user_data['current_match_index'] = 0
                context.user_data['changed_ingredient_indices'] = set()
                self._save_ingredient_matching_data(user_id, context)
            
            await self._show_ingredient_matching_results(update, context)
            return self.config.AWAITING_INGREDIENT_MATCHING
        
        elif action == "manual_match_ingredients":
            await query.answer("‚úã –ù–∞—á–∏–Ω–∞—é —Ä—É—á–Ω–æ–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ...")
            
            matching_result = context.user_data.get('ingredient_matching_result')
            if not matching_result:
                await query.message.reply_text("–û—à–∏–±–∫–∞: —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
                return self.config.AWAITING_CORRECTION
            
            await self.ui_manager.cleanup_all_except_anchor(update, context)
            await self._show_manual_matching_overview(update, context)
            return self.config.AWAITING_MANUAL_MATCH
        
        elif action == "rematch_ingredients":
            await query.answer("üîÑ –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞—é —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ...")
            
            receipt_data = context.user_data.get('receipt_data')
            if not receipt_data:
                await query.message.reply_text("–û—à–∏–±–∫–∞: –¥–∞–Ω–Ω—ã–µ —á–µ–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
                return self.config.AWAITING_CORRECTION
            
            if not await self._ensure_poster_ingredients_loaded(context):
                await query.message.reply_text("‚ùå –û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫ –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤ –∏–∑ Poster.\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
                return self.config.AWAITING_CORRECTION
            
            poster_ingredients = context.bot_data.get('poster_ingredients', {})
            await self.ui_manager.cleanup_all_except_anchor(update, context)
            
            # Perform matching again
            matching_result = self.ingredient_matching_service.match_ingredients(receipt_data, poster_ingredients)
            context.user_data['ingredient_matching_result'] = matching_result
            context.user_data['current_match_index'] = 0
            context.user_data['changed_ingredient_indices'] = set()
            
            user_id = update.effective_user.id
            self._save_ingredient_matching_data(user_id, context)
            
            # Clear from context so it will be loaded from storage next time
            context.user_data.pop('ingredient_matching_result', None)
            context.user_data.pop('changed_ingredient_indices', None)
            context.user_data.pop('current_match_index', None)
            
            await self._show_ingredient_matching_results(update, context)
            return self.config.AWAITING_INGREDIENT_MATCHING
        
        elif action == "upload_to_google_sheets":
            await query.answer("üìä –ó–∞–≥—Ä—É–∂–∞—é –¥–∞–Ω–Ω—ã–µ –≤ Google –¢–∞–±–ª–∏—Ü—ã...")
            
            receipt_data = context.user_data.get('receipt_data')
            matching_result = context.user_data.get('ingredient_matching_result')
            
            if not receipt_data or not matching_result:
                await query.message.reply_text("–û—à–∏–±–∫–∞: –¥–∞–Ω–Ω—ã–µ —á–µ–∫–∞ –∏–ª–∏ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
                return self.config.AWAITING_CORRECTION
            
            # Import here to avoid circular imports
            from services.google_sheets_service import GoogleSheetsService
            
            google_sheets_service = GoogleSheetsService(
                credentials_path=self.config.GOOGLE_SHEETS_CREDENTIALS,
                spreadsheet_id=self.config.GOOGLE_SHEETS_SPREADSHEET_ID
            )
            
            if not google_sheets_service.is_available():
                await query.message.reply_text("‚ùå Google Sheets —Å–µ—Ä–≤–∏—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.")
                return self.config.AWAITING_CORRECTION
            
            success, message = google_sheets_service.upload_receipt_data(
                receipt_data, matching_result, self.config.GOOGLE_SHEETS_WORKSHEET_NAME
            )
            
            if success:
                await query.message.reply_text(f"‚úÖ {message}")
            else:
                await query.message.reply_text(f"‚ùå {message}")
            
            return self.config.AWAITING_CORRECTION
        
        elif action == "generate_supply_file":
            await query.answer("üìÑ –ì–µ–Ω–µ—Ä–∏—Ä—É—é —Ñ–∞–π–ª –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –≤ –ø–æ—Å—Ç–µ—Ä...")
            
            receipt_data = context.user_data.get('receipt_data')
            matching_result = context.user_data.get('ingredient_matching_result')
            
            if not receipt_data or not matching_result:
                await query.message.reply_text("–û—à–∏–±–∫–∞: –¥–∞–Ω–Ω—ã–µ —á–µ–∫–∞ –∏–ª–∏ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
                return self.config.AWAITING_CORRECTION
            
            # Import here to avoid circular imports
            from services.file_generator_service import FileGeneratorService
            
            file_generator = FileGeneratorService()
            
            # Validate data
            is_valid, error_message = file_generator.validate_data(receipt_data, matching_result)
            if not is_valid:
                await query.message.reply_text(f"‚ùå {error_message}")
                return self.config.AWAITING_CORRECTION
            
            try:
                # Generate file
                file_content = file_generator.generate_supply_file(
                    receipt_data, matching_result, 'xlsx'
                )
                
                # Send file
                from telegram import InputFile
                import io
                
                file_buffer = io.BytesIO(file_content)
                file_buffer.name = f"supply_receipt_{receipt_data.get_receipt_hash()}.xlsx"
                
                await query.message.reply_document(
                    document=InputFile(file_buffer),
                    caption="üìÑ –§–∞–π–ª –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –≤ –ø–æ—Å—Ç–µ—Ä –≥–æ—Ç–æ–≤!"
                )
                
            except Exception as e:
                print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ñ–∞–π–ª–∞: {e}")
                await query.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ñ–∞–π–ª–∞: {e}")
            
            return self.config.AWAITING_CORRECTION
        
        return self.config.AWAITING_CORRECTION
    
    async def _ensure_poster_ingredients_loaded(self, context: ContextTypes.DEFAULT_TYPE) -> bool:
        """Ensure poster ingredients are loaded"""
        poster_ingredients = context.bot_data.get('poster_ingredients', {})
        
        if not poster_ingredients:
            from poster_handler import get_all_poster_ingredients
            poster_ingredients = get_all_poster_ingredients()
            
            if not poster_ingredients:
                return False
            
            context.bot_data["poster_ingredients"] = poster_ingredients
            print(f"DEBUG: Loaded {len(poster_ingredients)} poster ingredients")
        
        return True
    
    async def _show_ingredient_matching_results(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Show ingredient matching results"""
        matching_result = context.user_data.get('ingredient_matching_result')
        changed_indices = context.user_data.get('changed_ingredient_indices', set())
        
        if not matching_result:
            await self.ui_manager.send_temp(
                update, context, "–û—à–∏–±–∫–∞: –¥–∞–Ω–Ω—ã–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.", duration=5
            )
            return
        
        # Format results
        result_text = self.ingredient_formatter.format_matching_table(matching_result, changed_indices)
        
        # Create buttons
        keyboard = [
            [InlineKeyboardButton("‚úèÔ∏è –†—É—á–Ω–æ–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ", callback_data="manual_match_ingredients")],
            [InlineKeyboardButton("üîÑ –°–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—å –∑–∞–Ω–æ–≤–æ", callback_data="rematch_ingredients")],
            [InlineKeyboardButton("üìä –ó–∞–≥—Ä—É–∑–∏—Ç—å –≤ Google –¢–∞–±–ª–∏—Ü—ã", callback_data="upload_to_google_sheets")],
            [InlineKeyboardButton("üìÑ –ü–æ–ª—É—á–∏—Ç—å —Ñ–∞–π–ª –¥–ª—è –ø–æ—Å—Ç–µ—Ä", callback_data="generate_supply_file")],
            [InlineKeyboardButton("‚óÄÔ∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –∫ —á–µ–∫—É", callback_data="back_to_receipt")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await self.ui_manager.send_menu(update, context, result_text, reply_markup, 'Markdown')
    
    async def _show_manual_matching_overview(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Show manual matching overview"""
        matching_result = context.user_data.get('ingredient_matching_result')
        
        if not matching_result:
            await self.ui_manager.send_temp(
                update, context, "–û—à–∏–±–∫–∞: –¥–∞–Ω–Ω—ã–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.", duration=5
            )
            return
        
        # Filter items that need matching (not exact matches)
        items_needing_match = []
        for i, match in enumerate(matching_result.matches):
            if match.match_status.value != 'exact':
                items_needing_match.append((i, match))
        
        if not items_needing_match:
            await self.ui_manager.send_menu(
                update, context,
                "‚úÖ **–í—Å–µ –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã —É–∂–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω—ã!**\n\n"
                "–í—Å–µ —Ç–æ–≤–∞—Ä—ã –∏–º–µ—é—Ç —Ç–æ—á–Ω—ã–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è —Å –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–∞–º–∏ Poster.",
                InlineKeyboardMarkup([
                    [InlineKeyboardButton("‚óÄÔ∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –∫ –æ–±–∑–æ—Ä—É", callback_data="back_to_receipt")]
                ]),
                'Markdown'
            )
            return
        
        # Create overview text
        overview_text = f"**–†—É—á–Ω–æ–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤**\n\n"
        overview_text += f"üìä **–¢—Ä–µ–±—É—é—Ç —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è:** {len(items_needing_match)} –∏–∑ {len(matching_result.matches)}\n\n"
        overview_text += "**–í—ã–±–µ—Ä–∏—Ç–µ —Ç–æ–≤–∞—Ä –¥–ª—è —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è:**\n"
        
        # Create buttons for items needing match (2 per row)
        keyboard = []
        for i, (match_index, match) in enumerate(items_needing_match):
            status_emoji = "üü°" if match.match_status.value == 'partial' else "üî¥"
            button_text = f"{status_emoji} {match.receipt_item_name[:15]}"
            
            if i % 2 == 0:
                keyboard.append([InlineKeyboardButton(button_text, callback_data=f"select_item_{match_index}")])
            else:
                keyboard[-1].append(InlineKeyboardButton(button_text, callback_data=f"select_item_{match_index}"))
        
        # Add control buttons
        keyboard.extend([
            [InlineKeyboardButton("üîç –í—ã–±—Ä–∞—Ç—å –ø–æ–∑–∏—Ü–∏—é –¥–ª—è —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è", callback_data="select_position_for_matching")],
            [InlineKeyboardButton("‚óÄÔ∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –∫ –æ–±–∑–æ—Ä—É", callback_data="back_to_receipt")]
        ])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await self.ui_manager.send_menu(update, context, overview_text, reply_markup, 'Markdown')
    
    def _save_ingredient_matching_data(self, user_id: int, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Save ingredient matching data to storage"""
        matching_result = context.user_data.get('ingredient_matching_result')
        changed_indices = context.user_data.get('changed_ingredient_indices', set())
        receipt_data = context.user_data.get('receipt_data')
        
        if matching_result and receipt_data:
            receipt_hash = receipt_data.get_receipt_hash()
            self.ingredient_storage.save_matching_result(user_id, matching_result, changed_indices, receipt_hash)
