"""
Formatter for ingredient matching results
"""
from typing import List
from models.ingredient_matching import IngredientMatchingResult, IngredientMatch, MatchStatus


class IngredientFormatter:
    """Formatter for ingredient matching results"""
    
    def __init__(self):
        self.max_name_length = 15  # Maximum length for ingredient names in table
        self.max_suggestion_length = 15  # Maximum length for suggestion names
    
    def format_matching_table(self, result: IngredientMatchingResult, changed_indices: set = None) -> str:
        """
        Format ingredient matching results as a table
        
        Args:
            result: IngredientMatchingResult to format
            changed_indices: Set of indices that were manually changed (0-based)
            
        Returns:
            Formatted table string
        """
        if not result.matches:
            return "–ù–µ—Ç –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤ –¥–ª—è —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è."
        
        # Create table header
        table_lines = []
        table_lines.append("**–°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤:**\n")
        
        # Add summary
        summary = f"üìä **–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:** –í—Å–µ–≥–æ: {result.total_items} | "
        summary += f"üü¢ –¢–æ—á–Ω—ã—Ö: {result.exact_matches} | "
        summary += f"üü° –ß–∞—Å—Ç–∏—á–Ω—ã—Ö: {result.partial_matches} | "
        summary += f"üî¥ –ù–µ –Ω–∞–π–¥–µ–Ω–æ: {result.no_matches}\n"
        table_lines.append(summary)
        
        # Create table
        table_lines.append("```")
        table_lines.append(self._create_table_header())
        table_lines.append(self._create_table_separator())
        
        # Add table rows
        for i, match in enumerate(result.matches, 1):
            is_changed = changed_indices is not None and (i-1) in changed_indices
            table_lines.append(self._create_table_row(i, match, is_changed))
        
        table_lines.append("```")
        
        return "\n".join(table_lines)
    
    def _create_table_header(self) -> str:
        """Create table header"""
        return f"{'‚Ññ':<2} | {'–¢–æ–≤–∞—Ä':<{self.max_name_length}} | {'Poster':<{self.max_name_length}} | {'–°—Ç–∞—Ç—É—Å':<4}"
    
    def _create_table_separator(self) -> str:
        """Create table separator"""
        total_width = 2 + 3 + self.max_name_length + 3 + self.max_name_length + 3 + 4
        return "-" * total_width
    
    def _create_table_row(self, row_number: int, match: IngredientMatch, is_changed: bool = False) -> str:
        """Create a table row for a match"""
        # Truncate names if too long
        receipt_name = self._truncate_name(match.receipt_item_name, self.max_name_length)
        ingredient_name = self._truncate_name(
            match.matched_ingredient_name or "‚Äî", 
            self.max_name_length
        )
        
        # Get status emoji - if changed, show pencil instead of regular status
        if is_changed:
            status_emoji = "‚úèÔ∏è"
        else:
            status_emoji = self._get_status_emoji(match.match_status)
        
        return f"{row_number:<2} | {receipt_name:<{self.max_name_length}} | {ingredient_name:<{self.max_name_length}} | {status_emoji:<4}"
    
    def _truncate_name(self, name: str, max_length: int) -> str:
        """Truncate name if too long"""
        if len(name) <= max_length:
            return name
        return name[:max_length-3] + "..."
    
    def _get_status_emoji(self, status: MatchStatus) -> str:
        """Get emoji for match status"""
        if status == MatchStatus.EXACT_MATCH:
            return "üü¢"
        elif status == MatchStatus.PARTIAL_MATCH:
            return "üü°"
        else:
            return "üî¥"
    
    def format_suggestions_for_manual_matching(self, match: IngredientMatch, min_score: float = 0.5) -> List[dict]:
        """
        Get filtered suggestions for manual matching
        
        Args:
            match: IngredientMatch with suggestions
            min_score: Minimum score threshold (default 0.5 = 50%)
            
        Returns:
            List of suggestion dictionaries with score >= min_score
        """
        if not match.suggested_matches:
            return []
        
        # Filter suggestions by minimum score
        filtered_suggestions = [
            suggestion for suggestion in match.suggested_matches 
            if suggestion['score'] >= min_score
        ]
        
        return filtered_suggestions
    
    def format_manual_matching_instructions(self) -> str:
        """Format instructions for manual matching"""
        return (
            "**–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ —Ä—É—á–Ω–æ–º—É —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—é:**\n\n"
            "1. –í—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–º–µ—Ä –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è\n"
            "2. –ò–ª–∏ –≤–≤–µ–¥–∏—Ç–µ '0' –¥–ª—è –ø—Ä–æ–ø—É—Å–∫–∞ —ç—Ç–æ–≥–æ –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–∞\n"
            "3. –ò–ª–∏ –≤–≤–µ–¥–∏—Ç–µ 'search: <–Ω–∞–∑–≤–∞–Ω–∏–µ>' –¥–ª—è –ø–æ–∏—Å–∫–∞ –¥—Ä—É–≥–∏—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤\n\n"
            "–ü—Ä–∏–º–µ—Ä—ã:\n"
            "‚Ä¢ `1` - –≤—ã–±—Ä–∞—Ç—å –ø–µ—Ä–≤–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ\n"
            "‚Ä¢ `0` - –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å\n"
            "‚Ä¢ `search: tomato` - –Ω–∞–π—Ç–∏ –≤–∞—Ä–∏–∞–Ω—Ç—ã —Å 'tomato'"
        )
    
    def format_search_results(self, query: str, results: List[dict]) -> str:
        """
        Format search results for manual selection
        
        Args:
            query: Search query
            results: List of search results
            
        Returns:
            Formatted search results string
        """
        if not results:
            return f"–ü–æ –∑–∞–ø—Ä–æ—Å—É '{query}' –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ."
        
        lines = [f"**–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ –¥–ª—è '{query}':**\n"]
        
        for i, result in enumerate(results, 1):
            name = self._truncate_name(result['name'], self.max_suggestion_length)
            score = int(result['score'] * 100)
            lines.append(f"{i}. {name} ({score}%)")
        
        return "\n".join(lines)
